#import "conf.typ" : conf
#import "@preview/plotst:0.2.0"
#import "@preview/fletcher:0.4.5" as fletcher: diagram, node, edge

#show: conf.with(
  title: [Lection 5],
  type: "referat",
  info: (
      author: (
        name: [Смирнов],
        faculty: [КНиИТ],
        group: "251",
        sex: "male"
      ),
      inspector: (
        degree: "",
        name: ""
      )
  ),
  settings: (
    title_page: (
      enabled: true
    ),
    contents_page: (
      enabled: true
    )
  )
)

= Обращение к полям структур: цикл в цикле для работы с 2-мя структурами

```asm
start:
    mov AH, 9
    mov DX, offset message
    int 21h
    lea BX, st1   ; Адрес первой записи в BX
    mov CX, 2     ; Кол-во повторений внешнего цикла
m2:
    push CX
    mov SI, 0 
    mov CX, 3     ; Кол-во повторений внутреннего цикла
m1:
    push CX
    lea DX, [BX][SI] ; Адресация по базе с индексированием
    int 21h
    add SI, 9     ; Переход к следуещему полю
    pop CX
    loop m1

    add BX, type tst  ; переход к следующей записи
    ; BX + кол-во байтов, занимаемых структурой типа tst
    pop CX
    loop m2
    ret 

message DH "hello", 0dh, 0ah, "$"

    tst struc   ; описание структуры
        s DB ?
        f DB ?
        i DB ?
    tst ends
    st1 tst <"student $","Ivanov $", "Ivan, $">
    st2 tst <"student $","Petrov $", "Petr, $">
end start
```
Результат работы программы:
hello
student Ivanov Ivan,student Petrov Petr,

= Запись в ассемблере


запись в ассемблере так же, как и структура, состоит из данных различной длинны, но записи --- упакованные данные, занимающие неполные ячейки памяти (байт или слова), а их части. Т.е. поля записи представляют собой последовательности битов (разрядов), прижатые друг к другую Между полями не может быть пробелов. Размер полей может быть различным, но в сумме их размер не должен превышать 16 разрядов. То есть сумма размеров полей --- это размер записи. А размер записи может быть 8 или 16 разрядов. Если сумма разрядов полей меньше 8 или 16, то поля должны быть "прижаты" к правой границе поля, а лишние левые разряды равны 0, они к записи не имеют отношения, не влияют на неё и не используются. Чтобы использовать запись, нужно в начале описать её тип, а потом записать переменную такого типа. Описание типов в записи может располагаться в любом месте, но до описания переменных. Поля записи имеют собственные имена, располагаются в памяти как при описании слева направо, но обращаться к полям напрямую, как к полям структуры, нельзя.


Директива описания типа запис имеет вид:

  \<имя типа записи> record \<поле> {, \<поле>}

\<поле> :: = \<имя поля> : \<размер> [=\<выражение>]

Здесь \<размер>  \<выражение> --- это константные выражения.

\<размер> определяет размер поля в битах, \<выражение> определяет значение поля по умолчанию. Знак ? не допускается.

== Например:

графическое представление

* Здесь должна быть фотка*

Год, записанный двумя последними цифрами $ 2^6 < Y_(m a x) = 99 < 2^7$

Имена полей, также как и в структурах, должны быть уникальными в рамках всей программы,  в описании они перечисляются слева направо \<выражение> может отсутствовать, если оно есть, то его значение должно умещаться в отведенный ему размер в битах. Если для некоторого поля выражение отсутствует, то его значение по умолчанию равно нулю, неопределенных полей не может быть.

Определенное директиваой cord имя типа (Trec, TData) используется далее как директива для описания переменных --- записей такого типа.

* имя записи имя типа записи \<ачальные значения>, *

угловые скобки здесь не метасимволы, а символы языка, внутри которых через запятую указываются начальные значения полей.

Начальными значениями могут быть:

1. константное выражение 
2. знак ?
3. пусто

В отличие от структуры, знак ? определяет нулевое начальное значение, а \<\<пусто>>б как и в структуре, определяет начальное значение равным значению по умолчанию.

== Например

*здесь должна быть фотка*

так же, как и для структур:

```asm
Dat1 TData <00,,> = Dat1 TData <00>
Dat2 TData <,,> = Dat2 TData < >
```

Одной директивой можно описать массив записей, используя несколько параметров в поле операндов или конструкцию повторения, например:

```asm
MDat TData 100 Dup (< >)
```

Описали 100 записей с начальными значениями, равными принятыми по умолчанию.

Со всей записью в целом можно работать как обычно с байтами или со словами т.е. можно реализовать присваивание Rec1 = Rec2:

```asm 
mov AL, Rec2
mvo Rec1, AL
```

Для работы с отдельными полями записи существуют специальные операторы *width* и *mask*:

*width \<имя поля записи>*

*width \<имя записи или имя типа записи>*

Значением оператора width вляется размер в битах поля или всей записи в зависимости от операнда

оператор mask имеет вид:

```asm
Mask <имя поля записи>
Mask <имя записи или имя типа записи>
```

значением этого оператора является \<\<маска>> --- это байт или слово, в зависимости от размера записи, содержащее единицы в тех разрядах, которые принадлежат полю или всей записи, указанных в качестве операнда, и нули в остальных, не используемых разрядах. Например:

```asm
mask A = 00111000h
mask B = 00000111h 
mask Y = 111111000000000h
mask Rec1 = mask TRec = 00111111h
```

Этот оператор используестя для выделения полей записи.

== Пример

Выявить родившихся 1-го числа, для этого придется выделять поле D и сравнивать его значение с 1-ей.

```asm
m1: ----------------------------------------
    mov AX, Dat1
    and AX, mask D
    cmp AX, 1 
    je yes
no: ----------------------------------------
    ----------------------------------------
    jmp m1
yes: ---------------------------------------
```

Объединение (union) является типом данных, состоящим из нескольких переменных, которые хранятся, начиная с одного и того же адреса памяти (перекрывая друг друга). Этот тип данных есть во многих язывках программирования, например, в языке C. 

Пример на Ассемблере: 

```asm
pdate record d: 5, m:4, y:7=4 
udate struc 
    d db ?  ; Локальное имя!
    m db ?
    y dw 4 
udate ends
date union
    Dp pdate <> ; 2 байта
    Du udate <> ; 4 байта
    Z dw 3 dup (?) ; 6 байт
date ends
```

Описываем переменную:

*MyDate date \<>*

Обращаемся к ее полям:

```asm
mov ax, MyDate, Dp ; 2 байта
and ax, Mask d ; d --- глобальное имя из записи pdate
mov al, MyDate, Du, d 
mov ax, MyDate, Z ; ax := Z[0] 
mov ax, sizeof MyDate ; sizeof MyDate = 6
```

В данном случае имена полей в объединении, как и имена полей в структурах, локализованы внутри объединения. Объединения используются в основном для экономии места в памяти при хранении данных.

На рисунке показано расположение полей объединения с именем MyDate в памяти

```asm
Dp d, m, y 
Du d m y 
Z  Z[0] Z[1] Z[2]
```

*здесь должна быть фотка*

наложение полей объединения друг на друга

http://arch32.cs.msu.su/Text/Chapter_08.pdf


= Новая презентация: Подпрограммы, строки, списки, макросредства

= Работа с подпрограммами в ассемблере

Программа, оформленная как процедура, к которой обращение происходит из ОС, заканчивается команддой возврата ret,

Подпрограмма, как вспомогательный алгоритм, к которому возможно многократное оращение с помощью команды call, тоже оформляется как процедура с помощью директив proc и endp. Структуру процедуры можно оформить так

```asm 
<name proc> proc <parametr>
    <body proc>
    ret
<name proc> endp
```

В Ассемблере один тип подпрограмм --- процедура. Размещать ее можно в любом месте программы, но так, чтобы управление на нее не попадало случайно, а только по команде call. Поэтоому описание ПП принято располагать в конце программного семента (после последней исполняемой команды) или вначале его --- перед первой исполняемой командой.

= Графическое представление 

*Здесь надо вставить фотку*

= Замечания 

1. После имени в директивах proc и endp двоеточие не ставится, но имя считается меткой, адресом первой исполняемой команды процедуры.

2. Метки, описанные в ПП, не локализируются в ней, поэтому они должны быть уникалными в рамках всей программы.

3. Параметр в директиве начала процедуры одни FAR или NEAR

Основная проблема при работе с ПП в Ассемблере --- это передача параметров и возврат результатов в вызывающую программу.

Существуют различные способы передачи параметров:

1. по значению
2. по ссылке
3. по возвращаемому значению
4. по результату
5. отложенным вычислением

Параметры можно передавать: 

1. через регистры
2. в глобальных переменных 
3. через стек
4. в потоке кода
5. в блоке параметров

Передача параметров через регистры --- наиболее простой способ. Вызывающая программа записывает в некоторые регистры фактические параметры...

Процедура получает адрес начала этого блока при помощи любого из рассмотренных методов: в регистре, в переменной, в стеке, в коде или даже в другом блоке параметров. Примеры использования этого способа --- многие функции ОС и BIOS, например, поиск файла, использующий блок параметров DTA, или загрузка и исполнение программы, использующая блок параметров EPB.

= Передача параметров по значению и по ссылке.

При передачи параметров по значению процедуре передачется значение фактического параметра, оно копируется в ПП и ПП использует копию, поэтому изменение , можификация парметра оказывается невозможным. Этот механизм используется для передачи параметров небольшого размера.

Например, нужно вычислить *c = max(a, b) + max(7, a - 1)*. Здесь все числа знаковые, размером в слово. Используем пердачу параметров через регистры.

Процедура получает параметры через регистры AX и BX, результат возвращается в регистре AX.

Процедура: AX = max(AX, BX)

```asm
max proc
    cmp AX, BX
    jge met1
    mov AX, BX
met1: 
    ret
max endp
```

= Фрагмент вызывающей программы:

--------------------------------


--------------------------------

