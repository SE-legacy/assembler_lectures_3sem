#import "conf.typ" : conf
// #import "@preview/cetz:0.2.2"
#import "@preview/plotst:0.2.0"
#import "@preview/fletcher:0.4.5" as fletcher: diagram, node, edge

#show: conf.with(
  title: [Lection 2],
  type: "referat",
  info: (
      author: (
        name: [Григорев],
        faculty: [КНиИТ],
        group: "251",
        sex: "male"
      ),
      inspector: (
        degree: "",
        name: ""
      )
  ),
  settings: (
    title_page: (
      enabled: true
    ),
    contents_page: (
      enabled: true
    )
  )
)

= Команды условной передачи упраления.

после команд сравнения, реагир на флажки, 

Команды услоной передачи управления можно разделить на 3 группы:

1. используемые после команд сравнения
2. используемые после команд отличных от команд сравнения
```asm
JZ/JNZ
JC/JNC
JO/JNO
JS/JNS
JP/JNP
```
3. используемые после команды, реагирующие на значение регистра CX

В общем виде команду условной передачи можно записать так:

*JX \<метка>*

Здесь x --- это одна, две или три буквы, которые определяют усвия передачи управления. Метка указанная в поле операнда, должна отстоять от кома не далее чем   $-128 div  +127$

Примеры:
```asm
JE M1 ; передача управления на команду с меткой M1, если ZF=1 
JNE M2 ; передача управления на команду с меткой M2, если ZF=0 
JC M3 ;передача управления на команду с меткой M3, если CF=1 
JNC M4 ;предача управления на команду с меткой M4, если CF=0
```

*ADD AX,BX*

*JZ M*

если в результате сложения CF=1, то управление передается на команду с меткой M, иначе --- на команду , следующую за JC 

*SUB AX,BX*

*JZ MET*

если с результатом вычитания будет 0, ZF=1 и управление передается  на команду с меткой MET 

Часто команды передачи управления используются после команд сравнения *\<метка> CMP OP1, OP2*

По этой команде выполняются (OP1) --- (OP2) и результат никуда не посылается, формируются только флаги.

#image("image3/table1.png")

= Команды управления

Команды услоной передачи управления могут осуществлять только короткий переход, а команды безусловной передачи управления могут реализовать как короткую передачу так и длинную. Если необходимо осуществить условный дальний переход, то мжно использовать JX вместе JMP следующим образом:

*if AX = BX goto m* следует заменить на 
*if AX \< > BX goto L*

*Goto m* m---дальняя метка 

------------------------------------------------

*L:* ------------------------------------------ ; L--- близкая метка

На Ассемблере это будет так:
```asm
cmp AX,BX
jne L 
jmp m 
```

мет:---------------------------------------------------

L: ----------------------------------------------------

С помощью команд jx  jmp можно реализовать цикл с предусломием:
1.
``` 
while x>0 do S;
  beg: cmp x, byte ptr 0 
        jle fin
            S 
        jmp beg
  fin:  ----------------------------------
```
и с постусловием:

2. 
```
do S while x > 0:
    beg:
        S 
        cmp x, byte ptr 0 
        jg beg
    fin: ---------------------------------
```

= Команды для организации циклов

1. *loop \<метка>*
2. *loope \<метка>*                 *loopz \<метка>*
3. *Loopne \<метка>*                *Loopnz \<метка>*

По команде в форме (1): (CX) --- 1 и если (CX) \< > 0, \<метка> 

По (2): (CX)=(CX) --- 1 и если (CX) \< > 0 и одновременно  ZF=1, \<метка>

Цикл завершается, если или (CX) = 0  или ZF=0 или (CX)=(ZF)=0 

По (3): (CX)=(CX) --- 1 и если (CX) \< > 0 и одноверменно ZF=0, \<метка> 

Выход из цикла осуществляестя, если или (CX) = 0 или (ZF)=1 или одновременно (CX) = 0 и ZF = 1.

Примеры:
1.

m1:

---------------------
```
mov CX, 100
mov AX, DX
```
---------------------

m2:

```
loop m1
```

2.

m1:

---------------------
```
mov SI, 0 
mov CX, 100
push CX
```
---------------------

m2:

```
inc SI 
pop CX
loop m1
```

(если CX нужно использовать внутри цикла)

= Пример использования команд усл. перезода, сравнения и циклов

Дана матрица целых байтовых величин, размером 4*5, необходимо подсчитать количество нулей в каждой строке и заменить их числом 0FFh. Под стек отведем 256 байтов, необходимо программу оформим как две последовательные процедуры: внешняя (FAR) --- это связь с ОС, внутренняя (NEAR) --- постановленной задачи.

```asm
;prim.asm 
title prim.asm
page, 132
Sseg segment para stack 'stack'
    db 256 dup (?)
Sseg ends

Dseg segment para public 'data'
Dan db 0,2,5,0,91 ; адрес первого элемента массива
    db 4,0,0,15,47 ; имя --- Dan 
    db 24,15,0,9,55
    db 1,7,12,0,4 
Dseg edns

Cseg segment para public 'code'
    Assume cs: cseg, ds: dseg, ss: sseg
start proc far 
    push DS ; для связи
    push AX ; с ОС
    mov BX, Dseg ; загрузка адреса сегмента данных 
    mov DS, BX ; в регистр DS 
    call main
    ret 
start endp

main proc near 
    mov BX, Ofset Dan 
    mov CX, 4 ; кол-во повторений внешнего цикла

nz1: 
    push CX
    mov DL, 0 ; счетчик нулей в строке матрицы
    mov SI, 0 
    mov CX, 5 ; кол-во поторений внутреннего цикла

nz2:
    push CX 
    cmp byte ptr [BX + SI], 0 
    jne mz
    mov byte ptr [BX + SI], oFFh
    inc DL 

mz:
    inc SI 
    pop CX

kz2: 
    loop nz2
    add DL, '0' ; вывод на экран
    mov AH, 6 ; кол-во нулей 
    int 21h
    add BX,5 ; переход к следующей строке матрицы
    pop CX

kz1: 
    loop nz1
    ret 

main endp 

Cseg ends 

end start
```

= Массивы в Ассемблере

Мссивы в языке Ассемблер описываются директивами определения данных, возможно с использование кострукции повторения DUP 

Например, *x DW 30 dup (?)*

Так можно описатть массив x, состоящий из 30 элементов длинной в слово, но в этом описании не указано как нумеруются элементы массива, т.е. это может быть *x[0..29] и x[1..30]  x[k..29+k].*

Если в задаче жестко не оговорена нумерация элементов, то в Ассемблере удобнее считать элементы от нуля, тогда адрес любого элемента будет записываться наиболее просто.

*адрес (x[i]) = x + (type x) \* i* 

В общем виде, когда первый элемент имеет номер k, для одновременого массива будет: 

*адрес (x[i]) = x + (type x) \* (i - k)*

Для двумерного массива --- *A[0..n-1, 0..m-1]* адрес *(i,j)*-го элемента можно вычислить так: *адрес (A[i,j]) = A + m \* (type A) \* i + (tpye A) \* j*

С учетом этих формул для записи адреса элемента массива можно использовать различные способы адресации.

Для описанного выше массива слов, адрес его i-го элемента равен 

*x + 2\* i = type (x) \* i*

Т.е адрес состоит из двух частей: постоянной  и переменной 2 \* i, зависящей от номера элемента массива. Логично использовать адресацию приямую с индексированием: x --- смещение, a 2\*i --- в регистре модификаторе SI или DI x[i]

Для двумерного массива, например:

*A DD n DUP (m DUP (?)) : A[0..n - 1, 0..m - 1]*

получим

* адрес (A[i,j]) = A + m \* 4 \* i + 4 \* j *

Т.е. имеем в адресе постоянную часть A  и две переменных *m \* 4 \* i* и *4 \* j*, которые можно хранить в регистрах. Два модификатора есть в адресации по базе с индексирование, например: *A[BX][DI]*.




















