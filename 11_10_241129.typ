
#import "conf.typ" : conf
#import "@preview/plotst:0.2.0"
#import "@preview/fletcher:0.4.5" as fletcher: diagram, node, edge

#show: conf.with(
  title: [Lection 10],
  type: "referat",
  info: (
      author: (
        name: [Смирнов],
        faculty: [КНиИТ],
        group: "251",
        sex: "male"
      ),
      inspector: (
        degree: "",
        name: ""
      )
  ),
  settings: (
    title_page: (
      enabled: true
    ),
    contents_page: (
      enabled: true
    )
  )
)

= Макрокоманды. (Макросы)

Описание макроса, макроопределение имеет вид:

```
<имя макроса> Macro <формальные прпметры>
    LOCAL <список имен>
    <тело>
    endm
```

Первая строка --- это заголовок макроса, имя макроса будет использоваться для обращения к этому Макроопределению. Формальные параметры записываются через запятую, это локальные имена, никак не связанные с объектами программы. Кол-во Формальных параметров не ограничено, но они должны умещаться в одной строке. Поскольку на место каждой Макрокоманды записывается Макрорасширение, кроме того, одни и теже метки могут использоваться и в самой программе, чтобы не возникало ошибки \<\<метка уже определена>>, директива LOCAL \<список имен> перечисляет через запятую имена меток, которые будут использоваться в теле макроса.

\<тело> --- это копируемый фрагмент программы, любое кол-во любых предложений в которых используются формальные параметры.

*Макрокоманда* --- обращение к макросу:

```
<имя макроса> <фактические параметры>
```

*Фактические параметры* указываются через запятую или/и пробел. В качестве фактического параметра может бытть использован любой текст, в том числе и пустой, но он должен быть сбалансирован по кавычкам и угловым скобкам, и в нем не должно быть запятых, пробелов и точек с запятой вне кавычек и скобок, т.к. запятая и пробел могут отделять один параметр от другого, а точкой с запятой начинается коментарий. С помощью директивы *EXITM* можно осуществить досрочный выход из макроса, если использовать команды условной генерации

```asm
IF x ... endif
```

С помощью директивы 

```asm
PURGE <имя макроса>
```

можно отменить определенный ранее макрос. Эта директива часто используется сразу после директивы *INCLUDE*, включившей в текст файл с бльшим количеством готовых макроопределений.

= Примеры макросов

1. Использование макросов позволяет составлять программу в терминах более крупных операций. Опишем в виде макроса оператор *IF x\<y then GOTO L*

```asm
IF_L MACRO x, y ,L 
    mov AX, x
    cmp AX, y
    jl L 
endm
```

Используя этот макрос, поиск минимального из 3-х чисел запишется так:

```asm
; DX = min(A,B,C)
mov DX, A 
IF_L A, B, M1
mov DX, B
M1: 
    IF_L DX, C, M2
    mov DX, C
M2: ------------------------------------
```

После макрогенерации в программе будет текст:

```asm
    ---------------------------------------
mov DX, A 
mov AX, A 
cmp AX, B
jl M1
mov DX, B

M1: 
    mov AX, DX
    cmp AX, C 
    jl M2
    mov DX, C
M2: ---------------------------------------
```

2. *Обращение к прощедурам* будет нагляднее, если передачу параметров оформить как макрос.

Например вычислить CX = NOD(A,B) + NOD(C,D), сли есть процедура вычисления NOD(x,y), и результат ее находится в AX.

```asm
CALL_NOD MACRO x, y
    mov AX, x
    mov BX, y
    call NOD ; (AX = NOD(x,y))
endm
```

```asm
CALL_NOD MACRO A, B ; наглядное обращение к ПП с параметрами.
    mov AX, x       ; (CX) = NOD(A,B)
    CALL_NOD C, D   ; (AX) = NOD(C,D)
    add CX, AX      ; (CX) = NOD(A,B) + NOD (C,D)
endm
```

*Использование меток в макросах.*

Пример 1. Если в макроопределении используются метки, но нет директивы LOCAL, то после макрогенерации будет сообщение об ошибке --- дублирование меток:

*Фотка*

= Вычислить остаток от деления одного числа на другое с помощью вычитания (числа натуральные, r1 и r2 --- регистры)

```asm
MD Macro r1,r2    ; r1 = r1 mod r2
    LOCAL M, M1
    M: 
        cmp r1, r2    ; while r1 >= r2 DO r1 = r1 - r2
        jb M1
        sub r1, r2
        jmp M
    M1:
        endm
```

Обращения к макросу MD: (r1 = AX, r2 = BX)

1.

```asm
MD AX, BX
--------------------------------
??0000:
    cmp AX, BX
    jb ??0001
    sub AX, BX
    jmp ??0000
??0001
--------------------------------
```

2. 

```asm
MD CX, DX   ; (r1 = CX, r2 = DX)

--------------------------------
??0002:
    cmp CX, DX
    jb ??0003
    sub CX, DX
    jmp ??0002
??0003:
--------------------------------
```

Макрогенератор, встретив директиву Local M,M1, будет заменять метки M и M1 на специальные имена вида ??xxxx.

где xxxx --- четырхзначное 16-ричное число от $0000 div F F F F$

*Вложенные макросы.*

*Пример.* акрос для вывода строки на экран:

```asm
message MACRO string
mov dx, OFFSET string
mod ah, 09h
int 21h
ENDM
```

```asm
dos MACRO func ; макрос определения номера функции прерывания
    mov ah, func
    int 21h
ENDM
```

Тогда предыдущее макроопределение можно переписать так:

```asm
message MACRO string
    mov dx, offset string
    dos 09h
ENDM
```

Тогда макросы называются влоенными.

*Пример. Макрос для помещения в стек регистров из списка --- блок внутри макроса.*

```asm
push_regs MACRO reg_list
    IRP reg, <reg_list>
        push reg
    ENDM
ENDM
```

обращение к такой макрокоманде имеет вид:

*push_regs \<ax,cx,si,di>* здесь угловые скобки обязательны. Если их опустить, то получится, что у макроса четыре агрумента, а их всего один --- список регистров, воспринимаемый как единое целое.

Макробиблиотека представляет собой файл с текстами макроопределений,

Пусть файл с именем MYMACRO,MAC, содержит две макрокоманды.

```asm
; Макрокоманда endpr завершения прогаммы
endpr macro 
    mov AX, 4C00h
    int 2 In 
endm
; Макрокоманда delay настраиваемой програмной задержки

delay macro time  ; Параметр --- число шагов
    Local label1, label2  ; Локольные метки
    push CX   ; Сохраним внешний счетчик
    mov CX, time
    Label2:
          push CX  ; Сохраняем его в стеке кол-во повтор внешнего цикла
          mov CX, 200 
    Label1:
          loop label1  ; внутренний цикл
          pop CX  ; востановливаем внешний счетчик
          loop label2  ; Внешний цикл
          pop CX  ; восстановим CX программы
endm
```

Подключаем библиотеку директивой include MYMACRO,MAC

= Директивы условного ассемблирования (ДУА)

ДУА управляют процессом ассемблирования путем подключения или отключения фрагментов исходного текста программы. Общий вид

1. $" "$

```asm
if <выражение>
    if-часть
else
    else-часть
endif
```

2.$" "$

```asm
if <выражение>
    if-часть
elseif <выражение1>
    elseif-часть1
elseif <выражение2>
    elseif-часть2
---------------------------------
else
    else-часть
endif
```

ДУА в форме (2) используется аналогично операторам выбора в языках высокого уровня.

ДУА много, рассмотрим некоторые из них:

1. *if \<константное выражение> if-часть*

if-часть ассемблируется, включается в исходный текст программы, если значение выражения --- истина, т.е. не равно нулю, в противном случае работает else-часть, если она есть, если else-части нет, выполняется следующий за директивой if оператор.

2. $" "$
  - *ife константное выражение*
  - *elseife константное выражение*

if-часть работает, включаетсяв текст программы, если выражение ложно, равно нулю.
3. $" "$
  -
    ```asm
    ifdef метка ; if-часть работает, включает в текст программы
    ```
  -
    ```asm
    elseifdef метка ;если указанная метка определена
    ```
4. $" "$
  -
    ```asm
    ifndef метка ; if-часть работает, если
    ```
  -
    ```asm
    elseifndef метка ; указанная метка не определена
    ```
5. $" "$
  -
    ```asm
    ifb <аргумент> ; if-часть работает, если
    ```
  -
    ```asm
    elseifb <аргумент> ; значением аргумента является пробел
    ```
6. $" "$
  -
    ```asm
    ifnb <аргумент> ; if-часть работает, если значением
    ```
  -
    ```asm
    elseifnb <аргумент> ;  аргумента является не пробел
    ```
7. $" "$
  -
    ```asm
    ifdif <apr1>,<apr2> 
    ```
  -
    ```asm
    elseifdif <apr1>,<apr2> 
    ```

if-часть работает, если аргументы различны, прописаные и строчные буквы различаются

8. $" "$
  -
    ```asm
    ifdifi <apr1>,<apr2> 
    ```
  -
    ```asm
    elseifdifi <apr1>,<apr2> 
    ```

if-часть включается в исходный текст программы, если аргументы различны, прописные и строчные буквы не различаются

9. $" "$
  -
    ```asm
    ifdifn <apr1>,<apr2> 
    ```
  -
    ```asm
    elseifdifn <apr1>,<apr2> 
    ```

if-часть работает, если аргументы одинаковы, прописные и строчные буквы различаются

10. $" "$
  -
    ```asm
    ifdifni <apr1>,<apr2> 
    ```
  -
    ```asm
    elseifdifni <apr1>,<apr2> 
    ```

if-часть работает, если аргументы одинаковы, прописные и строчные буквы не различаются 

Здесь угловые скобки обязательны.

= Примеры использования ДУА

1. Использование ДУА непосредственно в Ассемблере. При отладке большой программы обычно

```asm

```

